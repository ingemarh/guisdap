%% ================================================================================
%% Legal Notice: Copyright (C) 1991-2008 Altera Corporation
%% Any megafunction design, and related net list (encrypted or decrypted),
%% support information, device programming or simulation file, and any other
%% associated documentation or information provided by Altera or a partner
%% under Altera's Megafunction Partnership Program may be used only to
%% program PLD devices (but not masked PLD devices) from Altera.  Any other
%% use of such megafunction design, net list, support information, device
%% programming or simulation file, or any other related documentation or
%% information is prohibited for any other purpose, including, but not
%% limited to modification, reverse engineering, de-compiling, or use with
%% any other silicon devices, unless such use is explicitly licensed under
%% a separate agreement with Altera or a megafunction partner.  Title to
%% the intellectual property, including patents, copyrights, trademarks,
%% trade secrets, or maskworks, embodied in any such megafunction design,
%% net list, support information, device programming or simulation file, or
%% any other related documentation or information provided by Altera or a
%% megafunction partner, remains with Altera, the megafunction partner, or
%% their respective licensors.  No other licenses, including any licenses
%% needed under any third party's intellectual property, are provided herein.
%% ================================================================================
%%
%% Generated by: CIC 12.1 Build 243 November, 2012
%% Generated on: 2020-12-24 14:42:32
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% CIC91_fir_comp_coeff genearats CIC compensation filter coefficients
% using frequency sampling method.
%
%    CIC91_fir_comp_coeff(L, Fs, Fc, plot, is_fxp, B) calculates compensation
%    filter coefficients and saves the coefficients to a file.
%
%    L      - FIR filter length (= number of taps = number of coefficients)
%    Fs     - FIR filter sample rate in Hz before decimation
%    Fc     - FIR filter cutoff frequency in Hz
%    plot   - True or false to draw filter responses graphically
%
%    Example (defults):
%    CIC91_fir_comp_coeff(31,80e6,4e6,true);


function [ht]=CIC91_fir_comp_coeff(L, Fs, Fc, p)
	%%%%%% User Parameters %%%%%%
	% Check if Signal Processing Toolbox is in the Matlab installation
	if (isempty(which('fir2')))
		fir2='fir2_octave';
	else
		fir2='fir2';
	end
	
	if(nargin < 1), L=[]; end
	if(nargin < 2), Fs=[]; end
	if(nargin < 3), Fc=[]; end
	if(nargin < 4), p=0; end

	if isempty(L), L = 31; end
	if mod(L,2) == 0
		fprintf('FIR filter length must be an odd number. %d is used instead.\n',L+1);
		L = L+1;
	end
	if isempty(Fs), Fs = 80e6; end
	if isempty(Fc), Fc = 4e6; end
	%%%%%% CIC filter parameters %%%%%%
	M = 1;			%% Differential Delay
	N = 5;			%% Number of Stages
	R=round(Fs/Fc/5);% 5 due to software decimation

	Fo = R*Fc/Fs;           %% Normalized Cutoff freq; 0<Fo<=0.5/M;
	if Fo>=1/4M
		error('Fo should be less than 1/(4M) for good performance')
	end
	%%%%%%% CIC Compensator Design using fir2.m %%%%%%
	p = 2e3;                %% Granulatiry
	s = 0.25/p;             %% Stepsize
	fp = [0:s:Fo];          %% Passband frequency samples
	fs = (Fo+s):s:0.5;      %% Stopband frequency samples
	f = [fp fs]*2;          %% Noramlized frequency samples; 0<=f<=1;
	Mp = ones(1,length(fp));  %% Passband response; Mp(1)=1
	Mp(2:end) = abs( M*R*sin(pi*fp(2:end)/R)./sin(pi*M*fp(2:end))).^N; %% Inverse sinc
	Mf = [Mp zeros(1,length(fs))];
	f(end) = 1;
	h = feval(fir2,L-1,f,Mf);     %% Filter order = filter length (L) - 1
	h = h/max(h);           %% Floating point coefficients, scaled it to 1
	
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	% Output filter coefficients to a file for Altera FIR Compiler           %
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	
	%%%%%%% Full resolution CIC filter response %%%%%%%%
	hrec = ones(1,R*M);
	tmph = hrec;
	
	for k=1:N-1
	    tmph = conv(hrec, tmph);
	end
	hcic = tmph;
	hcic = hcic/max(hcic);
	
	%%%%%%% Total Response %%%%%%%%%%%%%%%
	resp = upsample(h, R);
	ht = conv(hcic, resp);              %% Concatenation of CIC and fir2 FIR at high freqency
	
	if p
	no_data_points = 4096;              %% Number of data points to plot in the figure
	
	[Hcic, wt] = freqz(hcic, 1, no_data_points, Fs);      %% CIC Freq. Response
	[Hciccomp, wt] = freqz(resp, 1, no_data_points, Fs);  %% CIC Comp. response using fir2
	[Ht, wt] = freqz(ht, 1, no_data_points, Fs);          %% Total response for CIC + Compensation fir2
	
	warning off all                                       %% Turn the 'Log by zero' warning off
	Mcic = 20*log10(abs(Hcic)/(abs(Hcic(1))));            %% CIC Freq. Response
	Mciccomp = 20*log10(abs(Hciccomp)/(abs(Hciccomp(1))));%% CIC Comp. response using fir2
	Mt = 20*log10(abs(Ht)/(abs(Ht(1))));                  %% Total response for CIC + Compensation fir2
	warning on
	
	subplot(2,1,1)
		plot(wt/1e3, Mcic, wt/1e3, Mciccomp, wt/1e3, Mt)
		legend('CIC','CIC Comp','Total Response')
		ymax = max(Mciccomp)+1;
		ylim([-100 ymax]);
		title('CIC and its Compensation Filter Responses')
		grid
		xlabel('Frequency kHz');
		set(gca,'xlim',[0 10*Fc/1e3])
		ylabel('Filter Magnitude Response dB')
		subplot(2,1,2)
		plot((0:length(h)-1)*R/Fs*1e6,h,(0:length(resp)-1)/Fs*1e6,resp,(0:length(ht)-1)/Fs*1e6,ht)
		ylabel('Normilised Fir coeffs')
		xlabel('Delay \mus')
	end

function b = fir2_octave(n, f, m, grid_n, ramp_n, window)

  if nargin < 3 || nargin > 6
    print_usage;
  end

  % verify frequency and magnitude vectors are reasonable
  t = length(f);
  if t<2 || f(1)~=0 || f(t)~=1 || any(diff(f)<0)
    error ("fir2: frequency must be nondecreasing starting from 0 and ending at 1");
  elseif t ~= length(m)
    error ("fir2: frequency and magnitude vectors must be the same length");
  % find the grid spacing and ramp width
  elseif (nargin>4 && length(grid_n)>1) || ...
         (nargin>5 && (length(grid_n)>1 || length(ramp_n)>1))
    error ("fir2: grid_n and ramp_n must be integers");
  end
  if nargin < 4, grid_n=[]; end
  if nargin < 5, ramp_n=[]; end

  % find the window parameter, or default to hamming
  w=[];
  if length(grid_n)>1, w=grid_n; grid_n=[]; end
  if length(ramp_n)>1, w=ramp_n; ramp_n=[]; end
  if nargin < 6, window=w; end
  if isempty(window), window=my_hamming(n+1); end
  if ~isreal(window) || ischar(window), window=feval(window, n+1); end
  if length(window) ~= n+1, error ("fir2: window must be of length n+1"); end

  % Default grid size is 512... unless n+1 >= 1024
  if isempty (grid_n)
    if n+1 < 1024
      grid_n = 512;
    else
      grid_n = n+1;
    end
  end

  % ML behavior appears to always round the grid size up to a power of 2
  grid_n = 2 ^ nextpow2 (grid_n);

  % Error out if the grid size is not big enough for the window
  if 2*grid_n < n+1
    error ("fir2: grid size must be greater than half the filter order");
  end

  if isempty (ramp_n), ramp_n = fix (grid_n / 25); end

  % Apply ramps to discontinuities
  if (ramp_n > 0)
    % remember original frequency points prior to applying ramps
    basef = f(:); basem = m(:);

    % separate identical frequencies, but keep the midpoint
    idx = find (diff(f) == 0);
    f(idx) = f(idx) - ramp_n/grid_n/2;
    f(idx+1) = f(idx+1) + ramp_n/grid_n/2;
    f = [f(:);basef(idx)]';

    % make sure the grid points stay monotonic in [0,1]
    f(f<0) = 0;
    f(f>1) = 1;
    %f = unique([f(:);basef(idx)(:)]');
    f = unique([f(:);basef(idx)]');

    % preserve window shape even though f may have changed
    m = interp1(basef, basem, f);

    % axis([-.1 1.1 -.1 1.1])
    % plot(f,m,'-xb;ramped;',basef,basem,'-or;original;'); pause;
  end

  % interpolate between grid points
  grid = interp1(f,m,linspace(0,1,grid_n+1)');
  % hold on; plot(linspace(0,1,grid_n+1),grid,'-+g;grid;'); hold off; pause;

  % Transform frequency response into time response and
  % center the response about n/2, truncating the excess
  if rem(n,2) == 0
    b = ifft([grid ; grid(grid_n:-1:2)]);
    mid = (n+1)/2;
    b = real ([ b([end-floor(mid)+1:end]) ; b(1:ceil(mid)) ]);
  else
    % Add zeros to interpolate by 2, then pick the odd values below.
    b = ifft([grid ; zeros(grid_n*2,1) ;grid(grid_n:-1:2)]);
    b = 2 * real([ b([end-n+1:2:end]) ; b(2:2:(n+1))]);
  end

  % Multiplication in the time domain is convolution in frequency,
  % so multiply by our window now to smooth the frequency response.
  % Also, for matlab compatibility, we return return values in 1 row
  b = b(:)' .* window(:)';

function w=my_hamming(n)
w=.54-.46*cos(2*pi*(0:n-1)'/(n-1));

